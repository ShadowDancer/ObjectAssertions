using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ObjectAssertions.Configuration;
using ObjectAssertions.Generator.Utils;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace ObjectAssertions.Generator
{
    internal class ClassGenerator
    {
        private SemanticModel _semanticModel;
        private ObjectAssertionsConfiguration _configuration;
        private INamedTypeSymbol _typeSymbol;

        public static string GenerateSource(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel, ObjectAssertionsConfiguration configuration)
        {
            return new ClassGenerator(typeDeclaration, semanticModel, configuration).GenerateSource();
        }

        private ClassGenerator(
            TypeDeclarationSyntax typeDeclaration,
            SemanticModel semanticModel,
            ObjectAssertionsConfiguration configuration)
        {
            _semanticModel = semanticModel;
            _configuration = configuration;
            _typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol
                          ?? throw new ArgumentException(nameof(typeDeclaration));
        }

        private string GenerateSource()
        {
            // begin creating the source we'll inject into the users compilation
            using var writer = new StringWriter();
            var sourceWriter = new IndentedTextWriter(writer);


            GenerateAutogeneratedHeader(sourceWriter);

            GenerateNamespace(sourceWriter);
            using (sourceWriter.Scope())
            {
                List<IDisposable> containingTypeScopes = new();
                var containingTypes = _typeSymbol.GetContainingTypes();
                foreach (var containingType in containingTypes.Reverse())
                {
                    AddClassHeader(sourceWriter, containingType);
                    containingTypeScopes.Add(sourceWriter.Scope());
                }

                var classDeclaration = SyntaxFactory.ClassDeclaration(_typeSymbol.Name);
                classDeclaration = classDeclaration.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword));

                classDeclaration = AddObsoleteAttributeIfNeeded(classDeclaration);

                ConstructorDeclarationSyntax constructor = MemberGenerator.GenerateConstructor(_semanticModel, _configuration.AssertionClassName, _configuration.AssertedType, _configuration.AssertionFieldName);
                classDeclaration = classDeclaration
                                    .AddMembers(constructor)
                                    .AddMembers(GenerateFields())
                                    .AddMembers(GenerateAssertMethod())
                                    .AddMembers(GenerateCollectAssertionsMethod())
                ;

                classDeclaration = classDeclaration.NormalizeWhitespace();
                classDeclaration.WriteTo(writer);
                writer.WriteLine();

                foreach (var scope in containingTypeScopes)
                {
                    scope.Dispose();
                }
            }

            sourceWriter.Flush();
            return writer.GetStringBuilder().ToString();
        }

        private void GenerateAutogeneratedHeader(IndentedTextWriter sourceWriter)
        {
            string header = """
                        //------------------------------------------------------------------------------ 
                        // <auto-generated> 
                        // This code was generated by a source gnerator.
                        // </auto-generated> 
                        //------------------------------------------------------------------------------

                        // Disable obsolete members
                        #pragma warning disable CS0612
                        #pragma warning disable CS0618
                        #pragma warning disable CS0619
                        """;
            sourceWriter.WriteLine(header);
        }

        private MethodDeclarationSyntax GenerateAssertMethod()
        {
            return MemberGenerator.GenerateAssertMethod(_semanticModel, "Assert", _configuration.AssertionFieldName, _configuration.Members);
        }

        private MethodDeclarationSyntax GenerateCollectAssertionsMethod()
        {
            return MemberGenerator.GenerateCollectAssertionsMethod(_semanticModel, "CollectAssertions", _configuration.AssertionFieldName, _configuration.Members.ToList());
        }

        private void GenerateNamespace(IndentedTextWriter sourceWriter)
        {
            string namespaceDeclaration = _typeSymbol.ContainingNamespace.ToDisplayString(
                new SymbolDisplayFormat(
                    SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,
                    SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                    kindOptions: SymbolDisplayKindOptions.IncludeNamespaceKeyword));

            sourceWriter.WriteLine(namespaceDeclaration);
        }

        private void AddClassHeader(IndentedTextWriter sourceWriter, INamedTypeSymbol typeSymbol)
        {
            string typeDeclaration = typeSymbol.ToDisplayString(new SymbolDisplayFormat(
                SymbolDisplayGlobalNamespaceStyle.Included,
                SymbolDisplayTypeQualificationStyle.NameOnly,
                SymbolDisplayGenericsOptions.IncludeTypeParameters,
                SymbolDisplayMemberOptions.IncludeModifiers,
                kindOptions: SymbolDisplayKindOptions.IncludeTypeKeyword));

            sourceWriter.WriteLine("partial " + typeDeclaration);
        }

        private MemberDeclarationSyntax[] GenerateFields()
        {
            List<MemberDeclarationSyntax> members = new List<MemberDeclarationSyntax>()
            {
                MemberGenerator.GenerateBackingField(_semanticModel, _configuration.AssertedType, _configuration.AssertionFieldName)
            };
            
            foreach (var memberInfo in _configuration.Members)
            {
                members.Add(MemberGenerator.GenerateFromMemberInfo(_semanticModel, memberInfo));
            }

            return members.ToArray();
        }

        private ClassDeclarationSyntax AddObsoleteAttributeIfNeeded(ClassDeclarationSyntax classDeclaration)
        {
            var obsoleteMember = _configuration.Members.FirstOrDefault(m => m.ObsoleteInfo != null);
            if (obsoleteMember != null)
            {
                string message = $"One of the asserted {obsoleteMember.Symbol.Name}'s members is obsolete";
                
                var obsoleteAttribute = ObsoleteMemberHandler.GenerateObsoleteAttribute(message);
                return classDeclaration.AddAttributeLists(
                    SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(obsoleteAttribute)));
            }

            return classDeclaration;
        }
    }


}
