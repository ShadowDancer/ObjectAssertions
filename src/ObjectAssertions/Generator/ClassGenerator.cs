using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using ObjectAssertions.Configuration;
using ObjectAssertions.Generator.Utils;

namespace ObjectAssertions.Generator
{
    internal class ClassGenerator
    {
        private SemanticModel _semanticModel;
        private ObjectAssertionsConfiguration _configuration;
        private INamedTypeSymbol _typeSymbol;

        public static string GenerateSource(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel, ObjectAssertionsConfiguration configuration)
        {
            return new ClassGenerator(typeDeclaration, semanticModel, configuration).GenerateSource();
        }

        private ClassGenerator(
            TypeDeclarationSyntax typeDeclaration,
            SemanticModel semanticModel,
            ObjectAssertionsConfiguration configuration)
        {
            _semanticModel = semanticModel;
            _configuration = configuration;
            _typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol
                          ?? throw new ArgumentException(nameof(typeDeclaration));
        }

        private string GenerateSource()
        {
            // begin creating the source we'll inject into the users compilation
            using var writer = new StringWriter();
            var sourceWriter = new IndentedTextWriter(writer);


            GenerateAutogeneratedHeader(sourceWriter);

            GenerateNamespace(sourceWriter);
            using (sourceWriter.Scope())
            {
                List<IDisposable> containingTypeScopes = new();
                var containingTypes = _typeSymbol.GetContainingTypes();
                foreach (var containingType in containingTypes.Reverse())
                {
                    AddClassHeader(sourceWriter, containingType);
                    containingTypeScopes.Add(sourceWriter.Scope());
                }

                var classDeclaration = SyntaxFactory.ClassDeclaration(_typeSymbol.Name);
                classDeclaration = classDeclaration.AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword), SyntaxFactory.Token(SyntaxKind.PartialKeyword));

                ConstructorDeclarationSyntax constructor = MemberGenerator.GenerateConstructor(_semanticModel, _configuration.AssertionClassName, _configuration.AssertedType, _configuration.AssertionFieldName);
                classDeclaration = classDeclaration
                                    .AddMembers(constructor)
                                    .AddMembers(GenerateFields())
                                    .AddMembers(GenerateAssertMethod())
                                    .AddMembers(GenerateCollectAssertionsMethod())
                ;

                classDeclaration = classDeclaration.NormalizeWhitespace();
                classDeclaration.WriteTo(writer);
                writer.WriteLine();

                foreach (var scope in containingTypeScopes)
                {
                    scope.Dispose();
                }
            }

            sourceWriter.Flush();
            return writer.GetStringBuilder().ToString();
        }

        private void GenerateAutogeneratedHeader(IndentedTextWriter sourceWriter)
        {
            string header = @"
                //------------------------------------------------------------------------------ 
                // <auto-generated> 
                // This code was generated by a source gnerator.
                // </auto-generated> 
                //------------------------------------------------------------------------------";
            sourceWriter.WriteLine(header);
        }

        private MethodDeclarationSyntax GenerateAssertMethod()
        {
            return MemberGenerator.GenerateAssertMethod(_semanticModel, "Assert", _configuration.AssertionFieldName, _configuration.Members.Select(n => n.Name));
        }

        private MethodDeclarationSyntax GenerateCollectAssertionsMethod()
        {
            return MemberGenerator.GenerateCollectAssertionsMethod(_semanticModel, "CollectAssertions", _configuration.AssertionFieldName, _configuration.Members.Select(n => n.Name).ToList());

        }

        private void GenerateNamespace(IndentedTextWriter sourceWriter)
        {
            string namespaceDeclaration = _typeSymbol.ContainingNamespace.ToDisplayString(
                new SymbolDisplayFormat(
                    SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,
                    SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                    kindOptions: SymbolDisplayKindOptions.IncludeNamespaceKeyword));

            sourceWriter.WriteLine(namespaceDeclaration);
        }

        private void AddClassHeader(IndentedTextWriter sourceWriter, INamedTypeSymbol typeSymbol)
        {
            string typeDeclaration = typeSymbol.ToDisplayString(new SymbolDisplayFormat(
                SymbolDisplayGlobalNamespaceStyle.Included,
                SymbolDisplayTypeQualificationStyle.NameOnly,
                SymbolDisplayGenericsOptions.IncludeTypeParameters,
                SymbolDisplayMemberOptions.IncludeModifiers,
                kindOptions: SymbolDisplayKindOptions.IncludeTypeKeyword));

            sourceWriter.WriteLine("partial " + typeDeclaration);
        }

        private MemberDeclarationSyntax[] GenerateFields()
        {


            List<MemberDeclarationSyntax> members = new List<MemberDeclarationSyntax>()
            {
                MemberGenerator.GenerateBackingField(_semanticModel, _configuration.AssertedType, _configuration.AssertionFieldName)
            };
            foreach (var field in _configuration.Members)
            {
                switch (field)
                {
                    case IPropertySymbol propertySymbol:
                        members.Add(MemberGenerator.GenerateFromProperty(_semanticModel, propertySymbol));
                        break;
                    case IFieldSymbol fieldSymbol:
                        members.Add(MemberGenerator.GenerateFromField(_semanticModel, fieldSymbol));
                        break;

                    default:
                        break;
                }
            }

            return members.ToArray();
        }
    }


}
